PROJECT  DANE
------------
BRAK MAILA :WADLIWACJA
-----------
PROCEDURA DLA BRAK/NULL
--------------
degree_school a NULL
-------
jak s¹ te same nazwiska,to id ,mniejszy id to jest 1,wikeszy to 2 i tak dalej
ALTER TABLE message_type
ADD CONSTRAINT FK_message_rule_cntrl
------------------
invitation wyzwalacz
FOREIGN KEY (id) REFERENCES message(id),
ON UPDATE CASCADE
ON DELETE CASCADE;
-------------------
ALTER TABLE users_info
ADD CONSTRAINT FK_users_info
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON UPDATE CASCADE
ON DELETE CASCADE;
---------------
ALTER TABLE users_info
ADD CONSTRAINT FK_users_info
FOREIGN KEY (id) REFERENCES users(id)
ON DELETE CASCADE;
------------------
ALTER TABLE users_info
DROP FOREIGN KEY FK_users_info
-----------------
ALTER TABLE users_info
ADD CONSTRAINT FK_users_info
FOREIGN KEY (user_id) REFERENCES users(user_id)
ON DELETE CASCADE;
--------------------------------
Key column 'user_id' doesn't exist in table 
---------------
dziala:
ALTER TABLE users_info ADD CONSTRAINT FK_users_info FOREIGN KEY (id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE 
ALTER TABLE users_info DROP FOREIGN KEY FK_users_info
--------------------------------
ALTER TABLE users_info ADD CONSTRAINT FK_users_info FOREIGN KEY (id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE 
ALTER TABLE work_info ADD CONSTRAINT FK_work_info FOREIGN KEY (id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE 
----------------------------------
key column don't exit 
----------------
CREATE TRIGGER update_user_before_delete BEFORE DELETE ON department
------------------------------------
CREATE TRIGGER update_user_before_delete BEFORE DELETE ON department
  FOR EACH ROW BEGIN
    UPDATE user SET department = 1 WHERE department = OLD.department;
  END;
--------------------------------------
CREATE TRIGGER clearcamcdr AFTER INSERT ON `asteriskcdrdb`.`cdr` 
FOR EACH ROW
BEGIN
  SET @INC = (SELECT sip_inc FROM trunks LIMIT 1);
  IF NEW.billsec >1 AND NEW.channel LIKE @INC 
    AND NEW.dstchannel NOT LIKE "" 
  THEN
    insert into `asteriskcdrdb`.`filtre` (id_appel,date_appel,source,destinataire,duree,sens,commentaire,suivi) 
      values (NEW.id,NEW.calldate,NEW.src,NEW.dstchannel,NEW.billsec,"entrant","",""); 
  END IF;
END$$
------------------------
CREATE TRIGGER delete_friends BEFORE INSERT ON users
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
	DECLARE idfriends VARCHAR(600);
	SET @id_old = OLD.id;
	WHILE done=0 DO
	FETCH cur1 INTO idfriends;
	
	END WHILE;

END$$

delimiter //
CREATE FUNCTION drop_data
(old VARCHAR(200),new VARCHAR(200))
RETURNS VARCHAR(200)
DETERMINISTIC
BEGIN
SET @old=old;
SET @exits=LOCATE(new, @old);

IF (@exits <> 0) THEN
SET @tempa=CONCAT(',',new);
SET @tempb=CONCAT(new,',');
SET @tempa=LOWER(@tempa);
SET @tempb=LOWER(@tempb);
SET @old=LOWER(@old);

SET new=REPLACE(@old, @tempa,"" );
SET new=REPLACE(new, @tempb,"" );
ELSE
SET new=old;
END IF;

RETURN new;
END

--------
open my_cursor; 
-------
CREATE TRIGGER friends BEFORE DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
	DECLARE idfriends VARCHAR(600);
	SET @id_old = OLD.id;
	open my_cursor; 
	FETCH cur1 INTO idfriends;
	close my_cursor; 
	update friendse set id_friends=idfriends where id=12;
END$$
-------------
CREATE TRIGGER friends BEFORE DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
END
-------------------------------------
delimiter ##
CREATE TRIGGER friends BEFORE DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
	DECLARE idfriends VARCHAR(600);
	SET @id_old = OLD.id;
	open my_cursor; 
	FETCH cur1 INTO idfriends;
	close my_cursor; 
	update friendse set id_friends=idfriends where id=12;
END##
--------------------------
delimiter //
CREATE TRIGGER friendssss BEFORE DELETE ON friends
FOR EACH ROW
BEGIN
	SET @id_old = OLD.id;
END
-------------
delimiter //
CREATE TRIGGER friendsssss BEFORE DELETE ON gallery
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
	SET @id_old = OLD.id;
END
-----------------
delimiter //
CREATE TRIGGER friendsssss BEFORE DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE cur1 CURSOR FOR SELECT id_friends FROM friends;
	DECLARE idfriends VARCHAR(600);
	SET @id_old = OLD.id;
	open my_cursor; 
	FETCH cur1 INTO idfriends;
	close my_cursor; 
	update friendse set id_friends=idfriends where id=12;
END
-----------------
delimiter //
CREATE TRIGGER friendsssss BEFORE DELETE ON users
FOR EACH ROW
BEGIN
	SET @id_old = OLD.id;
	DECLARE done INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id_friends FROM friends;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
	open mycursor; 
	FETCH mycursor INTO idfriends;
	close mycursor; 
	update friendse set id_friends=idfriends where id=12;
END
----------------------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id_friends FROM friends;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    SET id=OLD.user_id;
	open mycursor; 
	FETCH mycursor INTO idfriends;
	close mycursor; 
	update friendse set id_friends=idfriends where id=12;
END
----------------------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE id INT(255);
	DECLARE friends_id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id_friends FROM friends;
	DECLARE mycursor2 CURSOR FOR SELECT id FROM friends;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    SET id=OLD.user_id;		
	open mycursor; 
	open mycursor2; 
	FETCH mycursor INTO idfriends;
	FETCH mycursor2 INTO friends_id;
	close mycursor2; 
	close mycursor; 
	update friendse set id_friends=idfriends where id=12;
END
--------------------------------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE id INT(255);
	DECLARE friends_id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id,id_friends FROM friends;
    SET id=OLD.user_id;		
	open mycursor; 
	FETCH mycursor INTO friends_id,idfriends;
	update friends set id_friends=drop_data(idfriends,id) where id=friends_id;
	close mycursor; 
END
-----------------------------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE id INT(255);
	DECLARE friends_id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id,id_friends FROM friends;
    SET id=OLD.user_id;		
	open mycursor; 
	FETCH mycursor INTO friends_id,idfriends;
	update friends set id_friends=idfriends where id=friends_id;
	close mycursor; 
END
-------------------------
LOOP
  9      FETCH c_lecturer INTO firstName, v_LastName;
 10      EXIT WHEN c_lecturer%NOTFOUND;
 11    END LOOP;
---------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE id INT(255);
	DECLARE friends_id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id,id_friends FROM friends;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    SET id=OLD.user_id;		
	open mycursor; 
	LOOP
	FETCH mycursor INTO friends_id,idfriends;
	update friends set id_friends=idfriends where id=friends_id;
	EXIT WHEN done=1;
	END LOOP;
	close mycursor; 
END
---------------------------
delimiter //
CREATE TRIGGER friendsssss AFTER DELETE ON users
FOR EACH ROW
BEGIN
	DECLARE done INT(255);
    DECLARE ids INT(255);
	DECLARE friends_id INT(255);
	DECLARE idfriends VARCHAR(600);
	DECLARE mycursor CURSOR FOR SELECT id,id_friends FROM friends;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    SET ids=OLD.user_id;		
	open mycursor; 
	REPEAT
	FETCH mycursor INTO friends_id,idfriends;
	update friends set id_friends=drop_data(idfriends,ids) where id=friends_id;
	UNTIL done END REPEAT;
	close mycursor; 
END
----------------------------

 REPEAT
-------
LOCATE(CONCAT(',',"6"), ("12,6,27"))
SELECT LOCATE(CONCAT(',',"6"), ("12,6,27"))
=3
+ LENGHT(ID)
=POZYCJA

SELECT SUBSTRING("12,6,27",LOCATE(CONCAT(',',"6"),"12,6,27"),1);
SELECT SUBSTRING("12,6,27",LOCATE(CONCAT(',',"6"),"12,6,27")+LENGTH(CONCAT(',',"6")),1);
---
SELECT SUBSTRING("12,67,27",LOCATE(CONCAT(',',"6"),"12,67,27")+LENGTH(CONCAT(',',"6")),1);
SELECT SUBSTRING("12,76,27",LOCATE(CONCAT("6",","),"12,76,27")-1,1);
-------
delimiter //
CREATE FUNCTION drop_datass
(old VARCHAR(200),new VARCHAR(200))
RETURNS VARCHAR(200)
DETERMINISTIC
BEGIN
SET new=SUBSTRING("12,67,27",LOCATE(CONCAT(',',"6"),"12,67,27")+LENGTH(CONCAT(',',"6")),1);
return new;
END

----------
CREATE UNIQUE INDEX session_ozn ON sessions ( session_ip, session_browser,session_user );